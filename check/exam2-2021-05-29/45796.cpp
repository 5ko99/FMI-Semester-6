// 
// ?? "??. ??????? ????????"
// ???????? ?? ?????????? ? ???????????
// ???? ???????-??????????? ???????????? 2020/21
// ????????? 2
// 
// ???: ??????  
// ??: 45796
// ???????????: ???????????
// ????: 1
// ??????????????? ?????: 4
// ???, ? ????? ?? ??????? ?? ???????????: 29.05
// ??????? ??? ?? ???????????: <9:00>
// ??? ?????????? ??????????: <???????? ???? ?? Visual C++, GCC ??? Clang> Visual C++
//

// (?????? ?? ???????? ???? ???????? ???? ???? ?? ?????????)
// ????? ??-???? ? ?????????? ?? Visual C++.
// ??? ?????????? ???? ??????????, ?????? ?? ?? ????????.
// ??? ???? strlen, strcmp ? ?.?. ?? ?????????? ???? deprecated,
// ????? ??? ???????????:
//
// * ?? ?????????? ??????????? ?????? ?? ???? ???????
//   (strlen_s, strcmp_s ? ?.?.). ? ???? ?????? ?????? ??
//   ???????? ???????? ??-???? #define ?????????.
//
// * ?? ?????????? _CRT_SECURE_NO_WARNINGS ????? ??
//   ???????? ??????????? header ??????? ?? ????????????
//   ??????????.
//
#define _CRT_SECURE_NO_WARNINGS 

#include <cassert>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

class editor;
class command {
public:
    command(const char* input) {
        unsigned int lenght = strlen(input);
        std::string temp_string;
        for (unsigned i = 0; i < lenght; i++) {
            if (input[i] != ' ') {
                temp_string.push_back(input[i]);
            }
            if(input[i] == ' ' || i == (lenght-1)) {
                cmd.push_back(temp_string);
                temp_string.clear();
            }
        }
    }

    std::size_t size() const {
        return cmd.size();
    }

    std::string operator[](std::size_t index) const {
        if (index >= size()) {
            throw std::invalid_argument("");
        }
        else {
            return cmd[index];
        }
    }
private:
    std::vector <std::string> cmd;
};

class processor {

public:
    processor(editor* edtr) {
        this->edtr = edtr;
   }
    bool is_valid(command& cmd) {
        unsigned int size = cmd.size();
        if (size == 1) {
            std::string command = cmd[0];
            if (command == "EXIT" || command == "SIZE") {
                return true;
            }
        }
        else  if (size == 3) {
            std::string command = cmd[0];
            if (command == "EDIT" || command == "SHOW") {
                return true;
            }
        }
        else {
            return false;
        }
    }

    bool execute(command& cmd) {
        if (is_valid(cmd)) {
            std::string command = cmd[0];
            try {
                if (command == "EXIT") {
                    edtr->close();
                    return true;
                }
                else if (command == "SIZE") {
                    std::cout << edtr->size();
                }
                else if (command == "EDIT") {
                    unsigned int first_argument = std::stoul(cmd[1], nullptr, 10);
                    unsigned int second_argument = std::stoul(cmd[2], nullptr, 10);
                    edtr->edit(first_argument, second_argument);
                }
                else if (command == "SHOW") {
                    unsigned int first_argument = std::stoul(cmd[1], nullptr, 10);
                    unsigned int second_argument = std::stoul(cmd[2], nullptr, 10);
                   
                }
            }
            catch (std::exception& except) {

            }
        }
    }
private:
    editor* edtr;
};

class editor {

public:
    editor(const std::string path) {
        this->path = path;
        file.open(path);
        if (!file.is_open()) {
            throw std::exception("File can not be opened!");
        }
    }

    ~editor() {
        file.close();
    }

    void close() {
        file.close();
    }

    bool open(std::string path) {
        if (file.is_open()) {
            close();
        }

        file.open(path);
        if (!file.is_open()) {
            return false;
        }
        else {
            return true;
        }
    }

    std::size_t size() const {

    }

    void edit(std::size_t offset, std::uint8_t value) {
        if (file.is_open()) {
           // file.write();
        }
        else {
            throw std::exception("File is not opened!");
        }
    }

    void display(std::ostream& out, std::size_t offset, std::size_t limit) {

    }

private:
    std::string path;
    std::fstream file;
};

int main()
{

    return 0;
}